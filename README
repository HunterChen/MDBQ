MongoDB Queue

Lightweight C++ Job Queue using MongoDB for queues

Control flow is either by you or using boost.asio.

Own control flow:

    // in your server program instance:
    Hub hub("localhost", "test.col");
    hub.insert_job(BSON("foo"<<1<<"bar<<2), 1000); // timeout in 1000 seconds

    // in your workers
    Client clt("localhost", "test.col");
    mongo::BSONObj task;
    clt.get_next_task(task);
    clt.log(BSON("level"<<0<<"progress"<<"10%"));
    clt.log(BSON("level"<<0<<"progress"<<"50%"));
    clt.checkpoint(); // flush log to server, mark that we're still working
    clt.log(BSON("level"<<0<<"progress"<<"80%"));
    clt.finish(BSON("baz"<<3));

Boost.Asio control flow (preferred):

    // on hub:
    boost::asio::io_service io;
    // [...]  (register polling of task generators)
    hub.reg(io, 1); // poll every second
    io.run();

    // on client:
    struct my_client : pubic mdbq::Client{
        my_client(string url, string prefix):mdbq::Client(url,prefix);
        void handle_task(const BSONObj& o){ 
            try{ /* do the task */ }
            catch(mdbq::timeout_exception){/* do nothing */}
        }
    };
    my_client clt("localhost", "test.mdbq");
    clt.reg(io, 1); // poll every second
    io.run();

Issues:

- Clients are not killed when timeouts occur, they will get a `timeout_exception' thrown
  WHEN THEY CALL "checkpoint()". So you have to ensure that potentially
  long-running functions call checkpoint() from time to time and catch this in
  your main loop!

- Poll frequency should not be too high. If you need tight loops, consider
  using ZMQ or the like.
